{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Jasper Chou","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"可变参数宏","slug":"可变参数宏","date":"2020-06-01T03:02:14.000Z","updated":"2020-06-01T03:10:54.726Z","comments":true,"path":"2020/06/01/可变参数宏/","link":"","permalink":"http://yoursite.com/2020/06/01/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%AE%8F/","excerpt":"","text":"为了在linux 打印输出调试定义了一个基于printf的简单的宏定义如下： #define IS_DEBUG 0 //日志输出开关,当设置为0时,是关闭 #if(IS_PR) #define J_PR(format, ...) \\ printf(&quot;FUNCTION:&quot; __FUNCTION__&quot; LINE: %d: &quot;format&quot;&quot;, __LINE__, ##__VA_ARGS__) #else #define J_PR(format, ...) #endif 说明：##VA_ARGS _ 其中##意思是，如果可变参数被忽略或为空，将使预处理器（ preprocessor ）去除掉它前面的那个逗号。 format 代替的是如下结构 （%s\\n,”test”）; ————- format is “%s\\n” and 可变参数宏_VA_ARGS is “test” (“test”) ; ————— format ===”test” and 可变参数宏 is== empty","categories":[],"tags":[]},{"title":"sql索引","slug":"sql索引","date":"2020-05-27T03:08:27.000Z","updated":"2020-05-27T08:13:49.473Z","comments":true,"path":"2020/05/27/sql索引/","link":"","permalink":"http://yoursite.com/2020/05/27/sql%E7%B4%A2%E5%BC%95/","excerpt":"","text":"索引： 在数据库中想要查询某一个条件如 typedef 与 typenam typedef unsigned char uchar; typedef uchar uint8; typedef uint8 TFlowPortId; typedef unsigned short ushort; typePOINTdef ushort uint16; typedef uint16 TFlowNodeId; typedef unsigned int uint; typedef uint uint32; _finddata_t &lt;io.h&gt;","categories":[],"tags":[{"name":"索引 (Indxe)","slug":"索引-Indxe","permalink":"http://yoursite.com/tags/%E7%B4%A2%E5%BC%95-Indxe/"}]},{"title":"flex bison","slug":"flex-bison","date":"2020-05-24T04:16:15.000Z","updated":"2020-05-24T14:45:49.454Z","comments":true,"path":"2020/05/24/flex-bison/","link":"","permalink":"http://yoursite.com/2020/05/24/flex-bison/","excerpt":"","text":"bison : 功能 bison和flex配合使用，可以将用户提供的语法规则转化为一个语法分析器。 bison的作用：通过产生式多次构造，最终得到一个动作表，然后利用这个动作表去解析句子。bison读取用户提供的语法产生式，生成一个C语言格式的动作表，并将其包含进一个名为yyparse()的C函数，这个函数的作用是利用这个动作表来解析token流，这个token流是由flex生成的词法分析器扫描源程序得到。","categories":[],"tags":[]},{"title":"inline const mutable this static ","slug":"inline const mutable this static ","date":"2020-05-16T01:00:00.465Z","updated":"2020-05-19T08:03:10.886Z","comments":true,"path":"2020/05/16/inline const mutable this static /","link":"","permalink":"http://yoursite.com/2020/05/16/inline%20const%20mutable%20this%20static%20/","excerpt":"","text":"1.Const: 1.1Const 在函数后面时候：表示这个函数不能更改类中的内容也就是成员变量。 1.2 定义Const 对象： 只能调用Const 函数，非Const对象可以调用Const 函数和非Const 函数 1.3 mutable（不稳定 容易改变的意思）与Const 相反 定义了mutable 成员函数 则const 成员函数中就能修改此成员函数2.this :2.1this 编译器负责把这个对象的地址传递给这个成员函数中的一个隐藏的this形参。对于系统来说关于成员的调用都是通过this来调用的是会是一种隐式调用。在普通函数中this相当于指向非const对象的const 指针（const * this）而在const 函数中代表（const Time *const 的this 类型的指针） //如下： class Time { void add_hour(int h); }; Time mytime; mytime.add_hour(&amp;mytime,3) //传递的时候系统会默认传递一个当前的指针回去作为this指针 //this 是一个系统的保留关键字不可显示调用. //静态函数和全局函数是不能使用this指针的 3.static​ 3.1局部静态变量和全局静态变量都保存在静态存储区都是默认不赋予初值的话系统会给予初值0. ​ 3.2static 类成员 存在与整个类中 调用的时候是类名：：static成员变量名或者类名.static成员变量进行操作 ​ 3.3 static 类函数 调用是 类名：：static 类函数或者 类名.static 类函数 都可以使用。在静态成员函数中是不能修改非静态成员的值的 ​ 3.4类中的static声明了后要在cpp 中定义静态成员变量（在此时分配内存只能在一个cpp 中定义那不然重复定义）","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"索引 (Indxe)","slug":"索引-Indxe","permalink":"http://yoursite.com/tags/%E7%B4%A2%E5%BC%95-Indxe/"}]}