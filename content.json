{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Jasper Chou","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"letCode","slug":"letCode1","date":"2020-07-24T07:55:52.000Z","updated":"2020-07-24T08:12:53.264Z","comments":true,"path":"2020/07/24/letCode1/","link":"","permalink":"http://yoursite.com/2020/07/24/letCode1/","excerpt":"","text":"题目描述：学校在拍年度纪念照时，一般要求学生按照 非递减 的高度顺序排列。 请你返回能让所有学生以 非递减 高度排列的最小必要移动人数。 注意，当一组学生被选中时，他们之间可以以任何可能的方式重新排序，而未被选中的学生应该保持不动。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/height-checker 示例： 输入：heights = [1,1,4,2,1,3]输出：3解释：当前数组：[1,1,4,2,1,3]目标数组：[1,1,1,2,3,4]在下标 2 处（从 0 开始计数）出现 4 vs 1 ，所以我们必须移动这名学生。在下标 4 处（从 0 开始计数）出现 1 vs 3 ，所以我们必须移动这名学生。在下标 5 处（从 0 开始计数）出现 3 vs 4 ，所以我们必须移动这名学生。 这道题目中有疑惑点会造成困扰：.关于示例中的4vs1 就一开混淆以为是和原表进行比对，没想到是和上面的两个数组两两比。 题目中其实意思是就是比较刷选后和筛选前的数进行对比看几个不一样，文件描述太绕了知道问题点之后就简单了先排序之后再进行比对： 第一种解法对与c++ 可以时候Vector 进行数组容器存储这样很方便比对。 class Solution { public: int heightChecker(vector&lt;int&gt;&amp; heights) { int size = heights.size(); vector&lt;int&gt; vec(heights); // 这很方便 sort(vec.begin(), vec.end()); //自己关于库函数使用很少以后要多使用 int i = 0; int j = 0; int count = 0; for(i = 0, j = 0; i &lt; size, j &lt; size; i++, j++) //实验下双小标使用 { if(heights[i] != vec[j]) { ++count; } } return count; } }; 第二种解法： 直接冒泡排序再检测： c ：（冒泡逐个相临比对排出最大或者最小：如1和2比 ，2和3比， 3和4比） int heightChecker(int* heights, int heightsSize){ int *add=calloc(heightsSize,sizeof(int)); int i,j,temp,num=0; for(i=0;i&lt;heightsSize;i++){ add[i]=heights[i]; } for(i=0;i&lt;heightsSize;i++){ //代表比较次数 for(j=0;j&lt;heightsSize-i-1;j++){ //代表每次比对 if(heights[j]&gt;heights[j+1]){ //冒泡 temp=heights[j]; heights[j]=heights[j+1]; heights[j+1]=temp; } } } for(i=0;i&lt;heightsSize;i++){ if(add[i]!=heights[i]) num++; } return num; }","categories":[],"tags":[{"name":"letCode 数组","slug":"letCode-数组","permalink":"http://yoursite.com/tags/letCode-%E6%95%B0%E7%BB%84/"}]},{"title":"并发并行","slug":"并发并行","date":"2020-06-30T02:17:59.000Z","updated":"2020-06-30T02:41:09.897Z","comments":true,"path":"2020/06/30/并发并行/","link":"","permalink":"http://yoursite.com/2020/06/30/%E5%B9%B6%E5%8F%91%E5%B9%B6%E8%A1%8C/","excerpt":"","text":"并行是物理时观下的同时执行，而并发是操作系统同线程这个模型抽象之后站在线程的视角上看到的“同时”执行。 比喻如下： 并发：早上给女朋友做早餐开两个灶，一会煎鸡蛋一会炒菜。 并行：早上给女朋友做早餐开两个灶，女朋友帮做两人同时煎鸡蛋和炒菜。 并发的关键是你有处理多个任务的能力，不一定要同时。并行的关键是你有同时处理多个任务的能力。","categories":[],"tags":[{"name":"并发和并行","slug":"并发和并行","permalink":"http://yoursite.com/tags/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C/"}]},{"title":"epollselect","slug":"epollselect","date":"2020-06-28T15:06:48.000Z","updated":"2020-06-29T01:23:54.310Z","comments":true,"path":"2020/06/28/epollselect/","link":"","permalink":"http://yoursite.com/2020/06/28/epollselect/","excerpt":"","text":"为什么要用select和epoll当需要确定io是否有数据的时候那这个时候没有 select和epoll 的多路复用技术那要想实现这个功能。 方法如下： ​ 1 直接recv 函数去接受所有io ​ 2 每个io会单独开个线程 缺点： 网络io中就算1000个io也就只会有1000个有数据 因此上面两种方法效率很低因此需要多路复用技术。","categories":[],"tags":[{"name":"epoll Select","slug":"epoll-Select","permalink":"http://yoursite.com/tags/epoll-Select/"}]},{"title":"查漏补缺","slug":"查漏补缺","date":"2020-06-20T07:02:48.000Z","updated":"2020-06-20T08:44:40.630Z","comments":true,"path":"2020/06/20/查漏补缺/","link":"","permalink":"http://yoursite.com/2020/06/20/%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/","excerpt":"","text":"&lt; 等运算符的优先级要大于= 赋值运算符因此要注意在同时使用的时候加上括号标识其优先级//example : int size = 10; if (size = -1 &lt; 0) { //now the size is 1; //比较语句的顺序如下： 因为&lt;优先级大于= 因此顺序如下 (size= (-1&lt;0)) //(-1&lt;0) result= 1 than the result will give size so the size=1; printf(&quot;size&quot;); } //this is right if((size =-1) &lt;0) { //now the size = -1 } const 和#define 的区别","categories":[],"tags":[{"name":"查漏补缺 优先级 const","slug":"查漏补缺-优先级-const","permalink":"http://yoursite.com/tags/%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-%E4%BC%98%E5%85%88%E7%BA%A7-const/"}]},{"title":"const_cast issue","slug":"const-cast-issue","date":"2020-06-11T05:51:58.000Z","updated":"2020-06-11T05:51:58.362Z","comments":true,"path":"2020/06/11/const-cast-issue/","link":"","permalink":"http://yoursite.com/2020/06/11/const-cast-issue/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"std::make_pair","slug":"std-make-pair","date":"2020-06-10T09:48:39.000Z","updated":"2020-06-10T10:06:51.348Z","comments":true,"path":"2020/06/10/std-make-pair/","link":"","permalink":"http://yoursite.com/2020/06/10/std-make-pair/","excerpt":"","text":"std::make_pair","categories":[],"tags":[{"name":"std::make_pair","slug":"std-make-pair","permalink":"http://yoursite.com/tags/std-make-pair/"}]},{"title":"std::regex Error record","slug":"std-regex-Error-record","date":"2020-06-10T09:42:26.000Z","updated":"2020-06-10T09:47:48.760Z","comments":true,"path":"2020/06/10/std-regex-Error-record/","link":"","permalink":"http://yoursite.com/2020/06/10/std-regex-Error-record/","excerpt":"","text":"当时运行执行std::regex的时候出现如下问题：一开始以为是正则表达式不对之后查询发现是gcc版本问题。 报错信息如下： The error message is: terminate called after throwing an instance of &#39;std::regex_error&#39; what(): regex_error Aborted I bisected it to commit 36b945 原因如下： You need at least gcc 4.9 to make regexps work with gcc,。 因为服务器中此时的gcc版本是4.8因此因为gcc版本问题出现如上问题","categories":[],"tags":[{"name":"std::regex","slug":"std-regex","permalink":"http://yoursite.com/tags/std-regex/"}]},{"title":"CUDA 执行模型","slug":"CUDA-执行模型","date":"2020-06-09T15:02:40.000Z","updated":"2020-06-09T23:59:50.773Z","comments":true,"path":"2020/06/09/CUDA-执行模型/","link":"","permalink":"http://yoursite.com/2020/06/09/CUDA-%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"CUDA 执行模型目标理解关于cuda中关于其模型内部架构等方面 GPU 中的有多SM 每个SM 单元能支持数百个线程的并发执行，所以一个GPU上并发执行数千个线程是有可能的。当启动一个内核网格时，它的线程被分配到可用的SM上进行执行，线程快一旦被调度到SM上，其中的线程只会在那个指定的SM上并发执行，多个线程块可能被分配到一个SM上，而且是根据SM资源的可用性调度的。同一个线程中的指令利用指令级并行进行流水线化。 CUDA 是采用单指令多线程（SIMY）架构来管理和执行线程。SIMT 中每个线程束中的所有线程在相同的程序地址上可以同时的开始执行，但是单独的线程任然有可能又不同的行为。（可以确保可以编写独立的线程并行代码） 在SIMT 中每个线程都： 有独立的执行路径 有自己的指令地址计数器 有自己的寄存器状态 线程束是（warp）一个32个线程为一组的，warp里每个线程都是可以同时执行相同的指令。每个线程都有自己的指令地址计数器和寄存器状态，并利用自身的数据执行当前的指令。每个SM都将分配给它的线块分配到32个warp中，然后再可用户的硬件资源上调度执行。","categories":[],"tags":[{"name":"CUDA 执行模型","slug":"CUDA-执行模型","permalink":"http://yoursite.com/tags/CUDA-%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"}]},{"title":"信号学习","slug":"信号学习","date":"2020-06-05T14:36:17.000Z","updated":"2020-06-13T03:50:39.806Z","comments":true,"path":"2020/06/05/信号学习/","link":"","permalink":"http://yoursite.com/2020/06/05/%E4%BF%A1%E5%8F%B7%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"信号的概念：​ 信号是一个通知，通知进程进程发生了某些事情。信号是突然发生的所以是*异步发生*的。信号的产生：由一个进程发送给另一个进程，或者由内核（可理解为操作系统）发送给进程。例如ctrl+c 这种中断信号或者内存越界等问题。 ​ 信号的名字都是由SIG开头的。 信号是一些正整数常量在linux 系统中是与宏的形式存在，宏在signal.h 中（user/include中。 ​ gcc 编译的时候文件头文件的的搜索顺序是从 1./usr/local/include 2. /usr/inclu当要包括库文件的时候连接路径：/usr/local/lib 然后 /usr/lib 路径下去寻找 kill 命令（发送一个信号给进程） kill 能给进程发送多种信号，当单独发送kill命令的时候一般为中止信号。 kill 的默认缺省动作（程序中不进行处理的化大部分是）是干掉进程 信号sigkill 和sigstop 是不能被忽略的无法让用户自己定义信号方式的。 信号的三个动作 信号的缺省动作一般是杀死这个进程 忽视此此动作（可以在代码中忽视）但SIGKILL 和SIGSTOP是不能被忽视的 捕捉信号可以捕捉信号重写写处理函数，但是SIGKILL 和SIGSTOP 是不能捕捉处理的。 ​","categories":[],"tags":[{"name":"信号学习","slug":"信号学习","permalink":"http://yoursite.com/tags/%E4%BF%A1%E5%8F%B7%E5%AD%A6%E4%B9%A0/"}]},{"title":"hash 索引","slug":"hash-索引","date":"2020-06-03T03:47:54.000Z","updated":"2020-06-03T03:47:54.700Z","comments":true,"path":"2020/06/03/hash-索引/","link":"","permalink":"http://yoursite.com/2020/06/03/hash-%E7%B4%A2%E5%BC%95/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"cuda","slug":"cuda","date":"2020-06-01T05:50:33.000Z","updated":"2020-06-03T14:30:00.947Z","comments":true,"path":"2020/06/01/cuda/","link":"","permalink":"http://yoursite.com/2020/06/01/cuda/","excerpt":"","text":"CUDA CUDA的线程模型： 如图可以看到，每个线程有自己的私有本地内存（Local Memory），而每个线程块有包含共享内存（Shared Memory）,可以被线程块中所有线程共享，其生命周期与线程块一致。此外，所有的线程都可以访问全局内存（Global Memory）。还可以访问一些只读内存块：常量内存（Constant Memory）和纹理内存（Texture Memory）。内存结构涉及到程序优化，这里不深入探讨它们。 在vector（矢量相加的时候）计算出每个线程索引的目的是为了指定每个线程负责处理每个位置的两个元素相加，从上面的图中更容易能理解。通过相关计算算出tid 比如是第一个Thread(0,0)的地址的时候会从相关的内存如Global Memory 中去那相对应的小标的数据放到自己的线程中去执行。 关于GPU 核调用1.add&lt;&lt;&lt;N,1&gt;&gt;&gt; （）代表 N 代表启动的并行线程快 ，1代表在CUDA运行时在每个线程快中创建的线程的数量。 2.总共启动的线程数量公式如下 N 个线程快* 1个线程/线程快 = N个并行线程 3.在GPU中硬件会将线程快的数量限制为不超过65535，最大的线程数量是不超过设备属性结构中的maxThreadsPerBlock域的值，一般对于当前的处理器而言这个线程快是512个线程。因此当超过这个线程的计算的时候要将线程和线程块结合起来才能实现。 4.在其中每个块中的线程不能超过512个最大线程限制，所以当要并行执行的线程数N 大于512时候就需要进行分块和分线程配合使用。有一种方法是固定每个块中线程的数目然后通过，比如限制每一个线程块的线程为128则此时可以计算出有多少个线程块，通过N/128 就可以计算出线程块，这样就能启动了N个线程同时运行。当然当N = 127 则代表0个线程为了避免这个问题可以（N+127）/128 的方式相当于求出大于等于N的128最小倍数，采用这个公式计算出线程块。（调用时候 kern &lt;&lt;&lt;(（N+127）/128,128)&gt;&gt;&gt;）();) ​ 但是有时候N很大时候会开启过多的线程则此时需要管理取的线程如下： //如果启动N个线程： int tid = threadIdx.x + blockIdx.x * blockDim.x; //可以通过tid 取得的线程数来进行去线程的控制 tid 代表已经开了几个线程并行了 if(tid &lt; N) //代表如果当前的取得的线程数目&lt; 总共要启动的线程数字N c[tid] = a[tid] + b[tid]; 问题：为什么需要计算线索引：下面的两个函数有区别嘛 __global__ void add(int *a, int *b, int *c){ int tid = blockIdx.x; //why should tid? if(tid &lt; N) c[tid] = a[tid] + b[tid]; //tid is must? } int count_dev = 0; __global__ void add(int *a, int *b, int *c){ int tid = blockIdx.x; //why should tid? if(count_dev&lt; N) c[count_dev] = a[count_dev] + b[count_dev]; //tid is must? count_dev ++;} 问题：关于tid += blockDim.x * gridDim.x 的使用是什么情况","categories":[],"tags":[{"name":"CUDA","slug":"CUDA","permalink":"http://yoursite.com/tags/CUDA/"}]},{"title":"可变参数宏","slug":"可变参数宏","date":"2020-06-01T03:02:14.000Z","updated":"2020-06-01T03:10:54.726Z","comments":true,"path":"2020/06/01/可变参数宏/","link":"","permalink":"http://yoursite.com/2020/06/01/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%AE%8F/","excerpt":"","text":"为了在linux 打印输出调试定义了一个基于printf的简单的宏定义如下： #define IS_DEBUG 0 //日志输出开关,当设置为0时,是关闭 #if(IS_PR) #define J_PR(format, ...) \\ printf(&quot;FUNCTION:&quot; __FUNCTION__&quot; LINE: %d: &quot;format&quot;&quot;, __LINE__, ##__VA_ARGS__) #else #define J_PR(format, ...) #endif 说明：##VA_ARGS _ 其中##意思是，如果可变参数被忽略或为空，将使预处理器（ preprocessor ）去除掉它前面的那个逗号。 format 代替的是如下结构 （%s\\n,”test”）; ————- format is “%s\\n” and 可变参数宏_VA_ARGS is “test” (“test”) ; ————— format ===”test” and 可变参数宏 is== empty","categories":[],"tags":[]},{"title":"sql索引","slug":"sql索引","date":"2020-05-27T03:08:27.000Z","updated":"2020-05-27T08:13:49.473Z","comments":true,"path":"2020/05/27/sql索引/","link":"","permalink":"http://yoursite.com/2020/05/27/sql%E7%B4%A2%E5%BC%95/","excerpt":"","text":"索引： 在数据库中想要查询某一个条件如 typedef 与 typenam typedef unsigned char uchar; typedef uchar uint8; typedef uint8 TFlowPortId; typedef unsigned short ushort; typePOINTdef ushort uint16; typedef uint16 TFlowNodeId; typedef unsigned int uint; typedef uint uint32; _finddata_t &lt;io.h&gt;","categories":[],"tags":[{"name":"索引 (Indxe)","slug":"索引-Indxe","permalink":"http://yoursite.com/tags/%E7%B4%A2%E5%BC%95-Indxe/"}]},{"title":"flex bison","slug":"flex-bison","date":"2020-05-24T04:16:15.000Z","updated":"2020-05-24T14:45:49.454Z","comments":true,"path":"2020/05/24/flex-bison/","link":"","permalink":"http://yoursite.com/2020/05/24/flex-bison/","excerpt":"","text":"bison : 功能 bison和flex配合使用，可以将用户提供的语法规则转化为一个语法分析器。 bison的作用：通过产生式多次构造，最终得到一个动作表，然后利用这个动作表去解析句子。bison读取用户提供的语法产生式，生成一个C语言格式的动作表，并将其包含进一个名为yyparse()的C函数，这个函数的作用是利用这个动作表来解析token流，这个token流是由flex生成的词法分析器扫描源程序得到。","categories":[],"tags":[]},{"title":"inline const mutable this static ","slug":"inline const mutable this static ","date":"2020-05-16T01:00:00.465Z","updated":"2020-05-19T08:03:10.886Z","comments":true,"path":"2020/05/16/inline const mutable this static /","link":"","permalink":"http://yoursite.com/2020/05/16/inline%20const%20mutable%20this%20static%20/","excerpt":"","text":"1.Const: 1.1Const 在函数后面时候：表示这个函数不能更改类中的内容也就是成员变量。 1.2 定义Const 对象： 只能调用Const 函数，非Const对象可以调用Const 函数和非Const 函数 1.3 mutable（不稳定 容易改变的意思）与Const 相反 定义了mutable 成员函数 则const 成员函数中就能修改此成员函数2.this :2.1this 编译器负责把这个对象的地址传递给这个成员函数中的一个隐藏的this形参。对于系统来说关于成员的调用都是通过this来调用的是会是一种隐式调用。在普通函数中this相当于指向非const对象的const 指针（const * this）而在const 函数中代表（const Time *const 的this 类型的指针） //如下： class Time { void add_hour(int h); }; Time mytime; mytime.add_hour(&amp;mytime,3) //传递的时候系统会默认传递一个当前的指针回去作为this指针 //this 是一个系统的保留关键字不可显示调用. //静态函数和全局函数是不能使用this指针的 3.static​ 3.1局部静态变量和全局静态变量都保存在静态存储区都是默认不赋予初值的话系统会给予初值0. ​ 3.2static 类成员 存在与整个类中 调用的时候是类名：：static成员变量名或者类名.static成员变量进行操作 ​ 3.3 static 类函数 调用是 类名：：static 类函数或者 类名.static 类函数 都可以使用。在静态成员函数中是不能修改非静态成员的值的 ​ 3.4类中的static声明了后要在cpp 中定义静态成员变量（在此时分配内存只能在一个cpp 中定义那不然重复定义）","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"letCode 数组","slug":"letCode-数组","permalink":"http://yoursite.com/tags/letCode-%E6%95%B0%E7%BB%84/"},{"name":"并发和并行","slug":"并发和并行","permalink":"http://yoursite.com/tags/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C/"},{"name":"epoll Select","slug":"epoll-Select","permalink":"http://yoursite.com/tags/epoll-Select/"},{"name":"查漏补缺 优先级 const","slug":"查漏补缺-优先级-const","permalink":"http://yoursite.com/tags/%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-%E4%BC%98%E5%85%88%E7%BA%A7-const/"},{"name":"std::make_pair","slug":"std-make-pair","permalink":"http://yoursite.com/tags/std-make-pair/"},{"name":"std::regex","slug":"std-regex","permalink":"http://yoursite.com/tags/std-regex/"},{"name":"CUDA 执行模型","slug":"CUDA-执行模型","permalink":"http://yoursite.com/tags/CUDA-%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"name":"信号学习","slug":"信号学习","permalink":"http://yoursite.com/tags/%E4%BF%A1%E5%8F%B7%E5%AD%A6%E4%B9%A0/"},{"name":"CUDA","slug":"CUDA","permalink":"http://yoursite.com/tags/CUDA/"},{"name":"索引 (Indxe)","slug":"索引-Indxe","permalink":"http://yoursite.com/tags/%E7%B4%A2%E5%BC%95-Indxe/"}]}